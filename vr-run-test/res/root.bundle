{"92aca09436674360863731d38f23827a.material": {"texturesMapping": {}, "flat": false, "cullState": {"frontFace": "CCW", "enabled": true, "cullFace": "Back"}, "uniforms": {"opacity": {"enabled": false, "value": 1}, "refractivity": {"enabled": false, "value": 0}, "materialAmbient": {"enabled": true, "value": [0.1, 0.1, 0.1, 1]}, "materialSpecular": {"enabled": true, "value": [0.6, 0.6, 0.6, 1]}, "fresnel": {"enabled": true, "value": 0.5}, "vertexColorAmount": {"enabled": true, "value": 1}, "materialSpecularPower": {"enabled": true, "value": 64}, "materialDiffuse": {"enabled": true, "value": [0.8, 0.8, 0.8, 1]}, "reflectivity": {"enabled": true, "value": 0.6}, "materialEmissive": {"enabled": true, "value": [0, 0, 0, 1]}, "discardThreshold": {"enabled": true, "value": 0.1}, "normalMultiplier": {"enabled": true, "value": 1}, "etaRatio": {"enabled": true, "value": -0.5}, "reflectionType": 0, "wrapSettings": {"enabled": true, "value": [0, 0]}}, "name": "Default Material 2", "license": "CC0", "created": "2016-02-22T14:26:02.844Z", "deleted": false, "wireframe": false, "dataModelVersion": 2, "blendState": {"blendEquation": "AddEquation", "blendSrc": "SrcAlphaFactor", "blendDst": "OneMinusSrcAlphaFactor", "blending": "NoBlending"}, "modified": "2016-02-22T14:26:02.844Z", "dualTransparency": false, "depthState": {"write": true, "enabled": true}, "shaderRef": "GOO_ENGINE_SHADERS/uber", "id": "92aca09436674360863731d38f23827a.material", "renderQueue": -1}, "4d2303a5ad484fea930530132d84ff03.entity": {"name": "Sphere", "license": "CC0", "tags": {}, "deleted": false, "created": "2016-02-26T15:46:13.823Z", "dataModelVersion": 2, "modified": "2016-02-26T15:46:13.823Z", "static": false, "components": {"meshData": {"shape": "Sphere", "shapeOptions": {"radialSamples": 32, "textureMode": "Projected", "radius": 0.5, "zSamples": 24}}, "transform": {"rotation": [-90, 0, 0], "scale": [100, 100, 100], "translation": [0, 0, 0]}, "meshRenderer": {"receiveShadows": true, "materials": {"4cfc09f9b76a4f4cad4a6032cdf0744a.material": {"materialRef": "4cfc09f9b76a4f4cad4a6032cdf0744a.material", "sortValue": 0}}, "reflectable": true, "cullMode": "Dynamic", "castShadows": true}, "script": {"scripts": {"1d99cc5178db4c6abb9907cdac38c730.scriptinstance": {"id": "1d99cc5178db4c6abb9907cdac38c730.scriptinstance", "name": "Instance of Stream video script", "scriptRef": "f262bb7418044b34ae6100230b7988c4.script", "sortValue": 0, "options": {"enabled": true, "videoTexture": {"enabled": true, "textureRef": "679f7c69547246e5a03cf501af127572.texture"}, "videoUrl": "res/5ce1b4e74a02b3b14199038b3880a2640f2a549c.mp4"}}}}}, "hidden": true, "id": "4d2303a5ad484fea930530132d84ff03.entity"}, "ebc5ac6898234f0d8eb1e629b2a7d6c4.entity": {"name": "Default Camera", "license": "CC0", "tags": {}, "deleted": false, "created": "2015-07-27T15:45:29.148Z", "dataModelVersion": 2, "modified": "2015-07-27T15:45:29.148Z", "static": false, "components": {"camera": {"fov": 45, "lockedRatio": false, "far": 1000, "followEditorCam": false, "projectionMode": "Perspective", "near": 1, "aspect": 1, "size": 5}, "transform": {"rotation": [0, 0, 0], "scale": [1, 1, 1], "translation": [0, 0, 0]}, "script": {"scripts": {"83a93026ad294009a907e314e461eed3.scriptInstance": {"scriptRef": "GOO_ENGINE_SCRIPTS/OrbitNPanControlScript", "options": {"maxAscent": 89.95, "whenUsed": true, "orbitSpeed": 0.005, "clampAzimuth": false, "maxAzimuth": 270, "minZoomDistance": 1, "enabled": true, "minAzimuth": 90, "minAscent": -89, "lookAtDistance": 1, "drag": 0.9, "dragButton": "Left", "panButton": "Right", "zoomSpeed": 1, "smoothness": 0.4, "maxZoomDistance": 1000}, "id": "83a93026ad294009a907e314e461eed3.scriptInstance", "sortValue": 0, "name": "OrbitNPan"}}}}, "hidden": false, "id": "ebc5ac6898234f0d8eb1e629b2a7d6c4.entity"}, "72b440a4a1fd4493ba4f8d77b1399e4d.script": {"body": "var setup = function(args, ctx, goo) {\n\t// Parse background color\n\tvar backgroundColor = [\n\t\tMath.floor(args.backgroundColor[0] * 255),\t\n\t\tMath.floor(args.backgroundColor[1] * 255),\t\n\t\tMath.floor(args.backgroundColor[2] * 255),\t\n\t];\n\t\n\t// Store stuff\n\tvar mrc = ctx.entity.meshRendererComponent;\n\tif (!mrc) { return; }\n\tctx.mat = mrc.materials[0];\n\tctx.oldTexture = ctx.mat.getTexture('DIFFUSE_MAP');\n\t\n\t// Scale for aspect ratio\n\tvar scale = ctx.entity.getScale().data;\n\tctx.ratio = scale[0] / scale[1];\n\t\n\t// Calculate texture size depending on ratio\n\tctx.size = [args.texSize, args.texSize];\n\tvar pot;\n\tif (ctx.ratio > 2) {\n\t\tpot = goo.MathUtils.nearestHigherPowerOfTwo(ctx.ratio);\n\t\tpot = Math.min(pot, 4096);\n\t\tctx.size[0] *= pot / 2;\n\t\tctx.ratio /= (pot / 2);\n\t} else if (ctx.ratio < 0.5) {\n\t\tpot = goo.MathUtils.nearestHigherPowerOfTwo(1 / ctx.ratio);\n\t\tpot = Math.min(pot, 4096);\n\t\tctx.size[1] *= pot / 2;\n\t\tctx.ratio *= (pot / 2);\n\t}\n\n\t// Create the canvas texture\n\tctx.texture = createTexture(goo, ctx.size[0], ctx.size[1], ctx.ratio);\n\tctx.texture.setStyle({\n\t\ttextAlign: args.textAlign,\n\t\tverticalAlign: args.verticalAlign,\n\t\tlineHeight: args.lineHeight,\n\t\tfont: args.font,\n\t\tmargin: args.margin,\n\t\tbackground: (args.transparent ? 'transparent' : backgroundColor),\n\t\twordWrap: args.wordWrap\n\t});\n\tctx.texture.setText(args.text);\n\n\tctx.bus = function(data) {\n\t\tif (data.entity === ctx.entity) {\n\t\t\tctx.texture.setText(data.text);\n\t\t}\n\t}\n\tgoo.SystemBus.addListener('quadtext.setText', ctx.bus);\n\tctx.mat.setTexture('DIFFUSE_MAP', ctx.texture);\n};\nvar cleanup = function(args, ctx, goo) {\n\t// Restore old texture\n\tgoo.SystemBus.removeListener('quadtext.setText', ctx.bus);\n\tctx.mat.setTexture('DIFFUSE_MAP', ctx.oldTexture);\n\tif (ctx.texture && ctx.texture.glTexture) {\n\t\tctx.texture.destroy(ctx.world.gooRunner.renderer.context);\n\t}\n};\n\nvar parameters = [{\n\tkey: 'text',\n\ttype: 'string',\n\t'default': 'Hello world!'\n}, {\n\tkey: 'transparent',\n\ttype: 'boolean',\n\t'default': true\n}, {\n\tkey: 'wordWrap',\n\ttype: 'boolean',\n\t'default': true\n}, {\n\tkey: 'backgroundColor',\n\ttype: 'vec3',\n\tcontrol: 'color',\n\t'default': [0,0,0]\n}, {\n\tkey: 'textAlign',\n\ttype: 'string',\n\tcontrol: 'select',\n\toptions: ['left', 'center', 'right'],\n\t'default': 'center'\n}, {\n\tkey: 'verticalAlign',\n\ttype: 'string',\n\tcontrol: 'select',\n\toptions: ['top', 'middle', 'bottom'],\n\t'default': 'middle'\n}, {\n\tkey: 'font',\n\ttype: 'string',\n\tcontrol: 'select',\n\toptions: ['Roboto', 'Helvetica', 'Times'],\n\t'default': 'Roboto'\n}, {\n\tkey: 'margin',\n\ttype: 'int',\n\tmin: 0,\n\t'default': 0\n}, {\n\tkey: 'lineHeight',\n\ttype: 'float',\n\tmin: 0.1,\n\t'default': 1.3\n}, {\n\tkey: 'texSize',\n\ttype: 'float',\n\tcontrol: 'select',\n\toptions: [128, 256, 512, 1024, 2048],\n\t'default': 512\n}];\n\n\nfunction createTexture(goo, width, height, ratio) {\n\tvar canvas = document.createElement('canvas')\n\tcanvas.width = width;\n\tcanvas.height = height;\n\tvar context = canvas.getContext('2d');\n\tvar totalMaxHeight = height / ratio;\n\t\n\t// Modifyables\n\tvar style = {\n\t\ttextAlign: 'left',\n\t\tverticalAlign: 'bottom',\n\t\tlineHeight: 1.3,\n\t\tfont: 'Roboto',\n\t\tmargin: 0,\n\t\tbackground: 'transparent',\n\t\twordWrap: true\n\t};\n\tvar text = {\n\t\tvalue: 'Hello world'\n\t};\n\tvar fontSize = 20;\n\t\n\t// Texture;\n\tvar tex = new goo.Texture(canvas);\n\ttex.setStyle = function(obj) {\n\t\tfor (var key in style) {\n\t\t\tif (obj[key] !== undefined) {\n\t\t\t\tstyle[key] = obj[key];\n\t\t\t}\n\t\t}\n\t\tthis._update();\n\t};\n\ttex.setText = function (str) {\n\t\ttext.value = str;\n\t\tthis._update();\n\t};\n\ttex._update = function () {\n\t\tthis._updateStyle();\n\t\tthis._printText();\n\t\tthis.setNeedsUpdate();\n\t}\n\ttex._clear = function() {\n\t\tif (style.background === 'transparent') {\n\t\t\tcontext.clearRect(0, 0, width, totalMaxHeight);\n\t\t} else {\n\t\t\tcontext.fillStyle = 'rgb(' + style.background.join(',') + ')';\n\t\t\tcontext.rect(0, 0, width, totalMaxHeight);\n\t\t\tcontext.fill();\n\t\t\tcontext.fillStyle = '#FFF';\n\t\t}\n\t}\n\ttex._updateStyle = function() {\n\t\t// Fixed\n\t\tcontext.fillStyle = '#FFF';\n\t\tcontext.textBaseline = 'bottom';\n\t\t\n\t\t//Custom\n\t\tcontext.textAlign = style.textAlign;\n\t\tcontext.font = fontSize + 'px ' + style.font;\n\t};\n\ttex._printText = function () {\n\t\tthis._updateStyle();\n\t\tcontext.save();\n\t\tcontext.scale(1, ratio);\n\n\t\tvar maxWidth = width - style.margin * 2;\n\t\tvar maxHeight = totalMaxHeight - style.margin * 2;\n\t\tvar lineHeight = style.lineHeight * fontSize;\n\n\t\tif (!style.wordWrap) {\n\t\t\tvar lineWidth = context.measureText(text.value).width;\n\t\t\tfontSize *= Math.min (maxWidth / lineWidth, maxHeight / lineHeight);\n\t\t\tlineHeight = style.lineHeight * fontSize;\n\t\t\tcontext.font = fontSize + 'px ' + style.font;\n\t\t\tvar x, y;\n\t\t\tif (style.verticalAlign === 'top') { y = lineHeight + style.margin; } \n\t\t\telse if (style.verticalAlign === 'middle') { y = (totalMaxHeight + lineHeight) / 2; }\n\t\t\telse if (style.verticalAlign === 'bottom') { y = totalMaxHeight - style.margin; }\n\t\t\tif (style.textAlign === 'left') { x = style.margin; }\n\t\t\telse if (style.textAlign === 'center') { x = width / 2; }\n\t\t\telse if (style.textAlign === 'right') { x = width - style.margin; }\n\t\t\tthis._clear();\n\t\t\tcontext.fillText(text.value, x, y);\n\t\t} else {\n\t\t\tvar size = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t\tvar offset = {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0\n\t\t\t}\n\t\t\tvar iterations = 0;\n\t\t\twhile (iterations < 100 && (\n\t\t\t\tsize.height > maxHeight || \n\t\t\t\tsize.height < maxHeight - lineHeight ||\n\t\t\t\tsize.width > maxWidth\n\t\t\t)) {\n\t\t\t\tif (size.width > maxWidth) {\n\t\t\t\t\tfontSize *= maxWidth / size.width;\n\t\t\t\t\tcontext.font = fontSize + 'px ' + style.font;\n\t\t\t\t} else if (size.height > 0) {\n\t\t\t\t\t// Update font size to fill\n\t\t\t\t\tfontSize *= 1 + (1 - maxHeight / size.height) * -0.1;\n\t\t\t\t\tcontext.font = fontSize + 'px ' + style.font;\n\t\t\t\t}\n\t\t\t\tlineHeight = style.lineHeight * fontSize;\n\t\t\t\tif (style.textAlign === 'left') { offset.x = style.margin; }\n\t\t\t\telse if (style.textAlign === 'center') { offset.x = width / 2; }\n\t\t\t\telse if (style.textAlign === 'right') { offset.x = width - style.margin; }\n\t\t\t\tthis._wrapText(size, offset, false);\n\t\t\t\t\n\t\t\t\titerations++;\n\t\t\t}\n\t\t\tif (style.verticalAlign === 'top') { offset.y = style.margin; } \n\t\t\telse if (style.verticalAlign === 'middle') { offset.y = (totalMaxHeight - size.height) / 2; }\n\t\t\telse if (style.verticalAlign === 'bottom') { offset.y = totalMaxHeight - style.margin - size.height; }\n\t\t\tthis._clear();\n\t\t\tthis._wrapText(size, offset, true);\n\t\t}\n\t\tcontext.restore();\n\t};\n\ttex._wrapText = function(size, offset, print) {\n\t\tvar lineHeight = fontSize * style.lineHeight;\n\t\tvar maxWidth = width - style.margin * 2;\n\n\t\tsize.width = 0;\n\t\tsize.height = offset.y;\n\t\tcontext.font = fontSize + 'px ' + style.font;\n\n\t\tvar lines = text.value.split('\\n');\n\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\tsize.height += lineHeight;\n\t\t\tvar line = lines[i];\n\t\t\tvar words = line.split(' ');\n\t\t\tvar outLine = '';\n\t\t\tfor (var j = 0; j < words.length; j++) {\n\t\t\t\tvar testLine = outLine + words[j] + ' ';\n\t\t\t\tvar w = context.measureText(testLine).width;\n\t\t\t\t// If line+word exceeds width, print the line and start a new one\n\t\t\t\tif (w > maxWidth) {\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tsize.width = Math.max(size.width, w);\n\t\t\t\t\t}\n\t\t\t\t\tif (print) { context.fillText(outLine, offset.x, size.height); }\n\t\t\t\t\toutLine = words[j] + ' ';\n\t\t\t\t\tsize.height += lineHeight;\n\t\t\t\t} else {\n\t\t\t\t\toutLine = testLine;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsize.width = Math.max(size.width, context.measureText(outLine).width);\n\t\t\t// Print the last line\n\t\t\tif (print) { context.fillText(outLine, offset.x, size.height); }\n\t\t}\n\t};\n\treturn tex;\n}", "name": "Text texture", "license": "CC0", "created": "2014-11-25T11:34:03.773633+00:00", "deleted": false, "modified": "2014-11-25T11:34:03.773665+00:00", "originalAsset": {"version": "cf886b37d0554800895fa4fa8f16ce83", "id": "ec75a454fe384cee899665d6baf4d721"}, "dataModelVersion": 2, "dependencies": {}, "id": "72b440a4a1fd4493ba4f8d77b1399e4d.script"}, "93cd06aae27c48d49d3edbb4a56017cb.texture": {"wrapS": "Repeat", "minFilter": "Trilinear", "name": "deathvalley_topomap_s.jpg", "license": "CC0", "flipY": true, "deleted": false, "magFilter": "Bilinear", "created": "2016-03-05T20:34:20.154Z", "dataModelVersion": 2, "modified": "2016-03-05T20:34:20.154Z", "matchFileName": "deathvalley_topomap_s.jpg", "repeat": [1, 1], "imageRef": "02bd18427e617411e11818ef2b383a4fd458b9a1.jpg", "offset": [0, 0], "id": "93cd06aae27c48d49d3edbb4a56017cb.texture", "generateMipmaps": true, "anisotropy": 1, "wrapT": "Repeat"}, "cb3463698ada4635aaf75f1001f6233a.environment": {"sound": {"dopplerFactor": 0, "maxDistance": 100, "reverb": 0, "rolloffFactor": 0.4, "volume": 1}, "globalAmbient": [0, 0, 0, 0], "license": "CC0", "created": "2015-07-27T15:45:29.143Z", "deleted": false, "dataModelVersion": 2, "modified": "2015-07-27T15:45:29.143Z", "fog": {"color": [1, 1, 1], "far": 996, "near": 0, "enabled": false}, "backgroundColor": [0, 0, 0, 1], "weather": {"snow": {"velocity": 10, "rate": 10, "enabled": false, "height": 25}}, "id": "cb3463698ada4635aaf75f1001f6233a.environment", "name": "Default Environment"}, "28de9dae45fa4a43afd7989f5cae6098.posteffects": {"name": "Post effects", "license": "CC0", "created": "2015-07-27T15:45:29.145Z", "deleted": false, "dataModelVersion": 2, "posteffects": {}, "modified": "2015-07-27T15:45:29.145Z", "id": "28de9dae45fa4a43afd7989f5cae6098.posteffects"}, "8e4efdba57834dc2b90aef72b3a40088.script": {"body": "var setup = function(args, ctx, goo) {\n\tctx.lastEvent = null;\n\tctx.lastOrientation = null;\n\tctx.orientation = new goo.Matrix3x3();\n\tctx.rotation = new goo.Matrix3x3();\n\tctx.firstRotation = null;\n\t\n\tctx.lastMoveEvent = null;\n\tctx.firstMovement = null;\t\n\tctx.movement = new goo.Vector3();\n// \tctx.accXsmooth = 0;\n//     ctx.accYsmooth = 0;\n// \tctx.accZsmooth = 0;\n//     ctx.factor = 0.9998;\n\n\tctx.currentQuat = new goo.Quaternion();\n\tctx.targetQuat = new goo.Quaternion();\n\n\tctx.deviceAcceleration = function(evt) {\n\t\tif (evt.acceleration.x && evt.acceleration.y && evt.acceleration.z) {\n\t\t\tctx.lastMoveEvent = evt;\n\t\t}\n\t};\n\tctx.deviceOrientation = function(evt) {\n\t\tif (evt.alpha && evt.beta && evt.gamma) {\n\t\t\tctx.lastEvent = evt;\n\t\t}\n\t};\n\tctx.reset = function() {\n\t\tctx.firstRotation = null;\n\t\tctx.firstMovement = null;\n\t};\n\tgoo.SystemBus.addListener('gyro.reset', ctx.reset);\n\twindow.addEventListener('deviceorientation', ctx.deviceOrientation);\n\twindow.addEventListener('devicemotion', ctx.deviceAcceleration);\n};\n\nvar cleanup = function(args, ctx, goo) {\n\twindow.removeEventListener('deviceorientation', ctx.deviceOrientation);\n\twindow.removeEventListener('devicemotion', ctx.deviceAcceleration);\n\tgoo.SystemBus.removeListener('gyro.reset', ctx.reset);\n};\nvar update = function(args, ctx, goo) {\n\tif (ctx.lastEvent) {\n\t\t// Grab the orientation\n\t\tyxz(\n\t\t\tctx.rotation,\n\t\t\tctx.lastEvent.beta * goo.MathUtils.DEG_TO_RAD,\n\t\t\tctx.lastEvent.alpha * goo.MathUtils.DEG_TO_RAD,\n\t\t\t- ctx.lastEvent.gamma * goo.MathUtils.DEG_TO_RAD\n\t\t);\n\t\t// Adapt to screen.\n\t\t// We want the entity so that a camera would point towards -Z with Y up\n\t\tif (window.orientation !== undefined) {\n\t\t\tif (ctx.lastOrientation !== window.orientation) {\n\t\t\t\tctx.orientation.fromAngles(\n\t\t\t\t\t- Math.PI / 2,\n\t\t\t\t\t- window.orientation * goo.MathUtils.DEG_TO_RAD,\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t\tctx.lastOrientation = window.orientation;\n\t\t\t}\n\t\t} else if (window.innerWidth > window.innerHeight) {\n\t\t\tif (ctx.lastOrientation !== 'landscape') {\n\t\t\t\tctx.orientation.fromAngles(\n\t\t\t\t\t- Math.PI / 2,\n\t\t\t\t\t- Math.PI / 2,\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t\tctx.lastOrientation = 'landscape';\n\t\t\t}\n\t\t} else {\n\t\t\tif (ctx.lastOrientation !== 'portrait') {\n\t\t\t\tctx.orientation.fromAngles(\n\t\t\t\t\t- Math.PI / 2,\n\t\t\t\t\t0,\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t\tctx.lastOrientation = 'portrait';\n\t\t\t}\n\t\t}\n\t\tctx.rotation.combine(ctx.orientation);\n\t\tif (!args.absolute) {\n\t\t\tif (!ctx.firstRotation) {\n\t\t\t\tctx.firstRotation = new goo.Matrix3x3();\n\t\t\t\tctx.firstRotation.copy(ctx.rotation).invert();\n\t\t\t}\n\t\t\tgoo.Matrix3x3.combine(ctx.firstRotation, ctx.rotation, ctx.rotation);\n\t\t}\n\t\tif (args.lerp === 1) {\n\t\t\tctx.entity.transformComponent.transform.rotation.copy(ctx.rotation);\n\t\t} else {\n\t\t\tctx.currentQuat.fromRotationMatrix(ctx.entity.transformComponent.transform.rotation);\n\t\t\tctx.targetQuat.fromRotationMatrix(ctx.rotation);\n\t\t\t\n\t\t\tctx.currentQuat.slerp(ctx.targetQuat, args.lerp);\n\t\t\tctx.currentQuat.toRotationMatrix(ctx.entity.transformComponent.transform.rotation);\n\t\t}\n\t\t\n// \t\tctx.entity.transformComponent.setUpdated();\n\t\tctx.lastEvent = null;\n\t}\n\t\n\tif (ctx.lastMoveEvent) {\n\t\t\tctx.currentPosition = ctx.entity.getTranslation();\n\t\t\tctx.movement = ctx.lastMoveEvent.acceleration;\n// \t\t    ctx.movement = (ctx.lastMoveEvent.acceleration.x, ctx.lastMoveEvent.acceleration.y, ctx.lastMoveEvent.acceleration.z);\n\t\t\tctx.currentPosition.lerp(ctx.movement, args.lerp);\n\t\t\tctx.entity.setTranslation(ctx.currentPosition.y, ctx.currentPosition.x, ctx.currentPosition.z);\n\t\t\tctx.lastMoveEvent = null;\n\t\t}\n};\n\nvar parameters = [{\n\tkey: 'absolute',\n\ttype: 'boolean',\n\tdefault: false\n}, {\n\tkey: 'lerp',\n\ttype: 'float',\n\tmin: 0,\n\tmax: 1,\n\tdefault: 0.9,\n\tcontrol: 'slider'\n}];\n\nfunction yxz(matrix, x, y, z) {\n\tvar d = matrix.data;\n\n\tvar cy = Math.cos(x);\n\tvar sy = Math.sin(x);\n\tvar ch = Math.cos(y);\n\tvar sh = Math.sin(y);\n\tvar cp = Math.cos(z);\n\tvar sp = Math.sin(z);\n\n\td[0] = ch * cp + sh * sp * sy;\n\td[3] = sh * cp * sy - ch * sp;\n\td[6] = cy * sh;\n\n\td[1] = cy * sp;\n\td[4] = cy * cp;\n\td[7] = - sy;\n\n\td[2] = ch * sp * sy - sh * cp;\n\td[5] = sh * sp + ch * cp * sy;\n\td[8] = cy * ch;\n}\n", "name": "device_sensors", "license": "CC0", "created": "2016-03-11T15:21:00.399Z", "deleted": false, "dataModelVersion": 2, "modified": "2016-03-11T15:21:00.399Z", "dependencies": {}, "id": "8e4efdba57834dc2b90aef72b3a40088.script"}, "647ce9e6c5a74e879740fbd519c2be00.entity": {"name": "sky", "license": "CC0", "tags": {}, "deleted": false, "created": "2016-02-24T09:27:23.859Z", "dataModelVersion": 2, "modified": "2016-02-24T09:27:23.859Z", "static": false, "components": {"transform": {"rotation": [0, 0, 0], "scale": [1, 1, 1], "translation": [0, 0, 0]}, "script": {"scripts": {"4dc237d4d0ec4d499492091e2228cec0.scriptinstance": {"id": "4dc237d4d0ec4d499492091e2228cec0.scriptinstance", "name": "Instance of video_loader", "scriptRef": "107c4dcd5e1c48e1989dd9086aafed2a.script", "sortValue": 0, "options": {"texture2": {"enabled": true}, "texture1": {"enabled": true, "textureRef": "679f7c69547246e5a03cf501af127572.texture"}, "enabled": false, "listenToStop": "stop", "listenToStart": "start"}}}}}, "hidden": false, "id": "647ce9e6c5a74e879740fbd519c2be00.entity"}, "843d5c34d3e6452fa3b44517b4b1488e.entity": {"name": "Directional 0", "license": "CC0", "tags": {}, "deleted": false, "created": "2015-07-27T15:45:29.196Z", "dataModelVersion": 2, "modified": "2015-07-27T15:45:29.196Z", "static": false, "components": {"light": {"direction": [0, 0, 0], "shadowCaster": false, "color": [1, 1, 1, 1], "intensity": 0.8, "range": 60, "specularIntensity": 1, "penumbra": 5, "angle": 30, "type": "DirectionalLight", "shadowSettings": {"fov": 55, "darkness": 1, "far": 60, "near": 1, "resolution": [256, 256], "shadowType": "Basic", "size": 100}}, "transform": {"rotation": [-38, 21, -18], "scale": [1, 1, 1], "translation": [16, 20.5, 23.3]}}, "hidden": false, "id": "843d5c34d3e6452fa3b44517b4b1488e.entity"}, "814eb3d13be3459fba60f42e75bac6e7.entity": {"name": "heightmap", "license": "CC0", "created": "2016-03-09T13:02:33.545Z", "deleted": false, "tags": {}, "dataModelVersion": 2, "modified": "2016-03-09T13:02:33.545Z", "static": false, "components": {"transform": {"rotation": [0, 0, 0], "scale": [1, 1, 1], "translation": [0, 0, 0]}, "script": {"scripts": {"b27aa7887a584b54b51f6a4a1d079bba.scriptinstance": {"scriptRef": "e46c79eb1221479fa6ea670616a3012a.script", "options": {"baseColor": [0, 0, 0], "lineColor": [1, 1, 1], "enabled": true, "texture": {"enabled": true, "textureRef": "93cd06aae27c48d49d3edbb4a56017cb.texture"}, "transparency": false, "lineWidth": 1}, "id": "6e2be119d65e4a62918cda83e34d628a.scriptInstance", "sortValue": 0, "name": "Custom script"}}}}, "hidden": false, "id": "814eb3d13be3459fba60f42e75bac6e7.entity"}, "9add1c4e82254fccb360ff1cd555c957.sound": {"name": "wind1", "license": "CC0", "created": "2016-03-11T22:11:24.024Z", "deleted": false, "audioRefs": {"mp3": "10072252dbacbea5dfd99e086586909e2d98d179.mp3"}, "dataModelVersion": 2, "modified": "2016-03-11T22:11:24.024Z", "volume": 1, "spatialize": false, "id": "9add1c4e82254fccb360ff1cd555c957.sound", "loop": true, "autoPlay": true}, "770efcf2e3ad4e5493ec103921c21a33.material": {"texturesMapping": {}, "flat": false, "cullState": {"frontFace": "CCW", "enabled": true, "cullFace": "Back"}, "uniforms": {"opacity": {"enabled": false, "value": 1}, "refractivity": {"enabled": false, "value": 0}, "materialAmbient": {"enabled": true, "value": [0, 0, 0, 1]}, "materialSpecular": {"enabled": true, "value": [0.6, 0.6, 0.6, 1]}, "fresnel": {"enabled": true, "value": 0}, "reflectivity": {"enabled": true, "value": 0}, "materialSpecularPower": {"enabled": true, "value": 64}, "materialDiffuse": {"enabled": true, "value": [1, 1, 1, 1]}, "vertexColorAmount": {"enabled": true, "value": 1}, "materialEmissive": {"enabled": true, "value": [1, 1, 1, 1]}, "discardThreshold": {"enabled": true, "value": 0.1}, "normalMultiplier": {"enabled": true, "value": 1}, "etaRatio": {"enabled": true, "value": -0.5}, "reflectionType": 0, "wrapSettings": {"enabled": true, "value": [0, 0]}}, "name": "Default Material", "license": "CC0", "created": "2016-03-07T16:49:56.269Z", "deleted": false, "wireframe": false, "dataModelVersion": 2, "blendState": {"blendEquation": "AddEquation", "blendSrc": "SrcAlphaFactor", "blendDst": "OneMinusSrcAlphaFactor", "blending": "TransparencyBlending"}, "modified": "2016-03-07T16:49:56.269Z", "dualTransparency": true, "depthState": {"write": true, "enabled": true}, "shaderRef": "GOO_ENGINE_SHADERS/uber", "id": "770efcf2e3ad4e5493ec103921c21a33.material", "renderQueue": -1}, "679f7c69547246e5a03cf501af127572.texture": {"wrapS": "Repeat", "minFilter": "Trilinear", "imageRef": "5ce1b4e74a02b3b14199038b3880a2640f2a549c.mp4", "license": "CC0", "flipY": true, "deleted": false, "name": "videoplayback.mp4_2.mp4", "magFilter": "Bilinear", "created": "2016-02-24T12:58:55.972Z", "dataModelVersion": 2, "modified": "2016-02-24T12:58:55.972Z", "repeat": [1, 1], "lodBias": 0, "offset": [0, 0], "id": "679f7c69547246e5a03cf501af127572.texture", "lazy": true, "generateMipmaps": true, "anisotropy": 1, "wrapT": "Repeat"}, "64f47c2064f746999a6db20581dbfb40.entity": {"name": "VR Camera", "license": "CC0", "tags": {}, "deleted": false, "created": "2016-02-24T09:01:44.620Z", "dataModelVersion": 2, "originalAsset": {"version": "3557785339bf43edb490080807e0b2f8", "id": "35a0371261c349a2adbeb3ca0fedaf00"}, "modified": "2016-02-24T09:01:44.620Z", "static": false, "components": {"sound": {"volume": 1, "sounds": {"9add1c4e82254fccb360ff1cd555c957.sound": {"soundRef": "9add1c4e82254fccb360ff1cd555c957.sound", "sortValue": 0}}}, "camera": {"fov": 55, "lockedRatio": false, "far": 1000, "followEditorCam": false, "projectionMode": "Perspective", "near": 0.1, "aspect": 1, "size": 5}, "transform": {"rotation": [0, 0, 0], "scale": [1, 1, 1], "translation": [0, 0, 1], "children": {"763dc89e7b4649bea068cff5bd7797e4.entity": {"entityRef": "763dc89e7b4649bea068cff5bd7797e4.entity", "sortValue": 0}}}, "script": {"scripts": {"7b1fc90a87914e22a7d57f7ce4247f6c.scriptinstance": {"id": "7b1fc90a87914e22a7d57f7ce4247f6c.scriptinstance", "name": "Custom script", "scriptRef": "f758d1b3cb4f4a43b36de389c39550d0.script", "sortValue": 2, "options": {"enabled": true}}, "300b1bd8dc9547f3b681284a9329ccf9.scriptinstance": {"id": "300b1bd8dc9547f3b681284a9329ccf9.scriptinstance", "name": "Custom script", "scriptRef": "b88ee439142b4ba5b918fdc3fd3cc83d.script", "sortValue": 0, "options": {"boost3D": 2, "enabled": true}}, "5609a7dbb0604b0589ff75b848384f2e.scriptinstance": {"id": "5609a7dbb0604b0589ff75b848384f2e.scriptinstance", "name": "Instance of 'MouseLookScript'", "scriptRef": "GOO_ENGINE_SCRIPTS/MouseLookScript", "sortValue": 3, "options": {"maxAscent": 89.95, "whenUsed": true, "maxAzimuth": 90, "button": "Left", "clampAzimuth": false, "enabled": true, "minAzimuth": -90, "minAscent": -89.95, "speed": 1}}, "908a1db785594bcfaf67e824dcdaabee.scriptinstance": {"id": "908a1db785594bcfaf67e824dcdaabee.scriptinstance", "name": "Instance of Device Orientation script 2", "scriptRef": "8e4efdba57834dc2b90aef72b3a40088.script", "sortValue": 4, "options": {"absolute": false, "enabled": true, "lerp": 0.9}}}}}, "hidden": false, "id": "64f47c2064f746999a6db20581dbfb40.entity"}, "ae6a528167ca4709b0954b9ace7bcac8.entity": {"name": "text", "license": "CC0", "tags": {}, "deleted": false, "created": "2016-03-09T13:26:50.691Z", "dataModelVersion": 2, "modified": "2016-03-09T13:26:50.691Z", "static": false, "components": {"meshData": {"shape": "Quad"}, "transform": {"rotation": [0, 0, 0], "scale": [10, 10, 10], "translation": [-1.7056150436401367, 5.023013114929199, -29.057449340820312]}, "meshRenderer": {"receiveShadows": true, "materials": {"770efcf2e3ad4e5493ec103921c21a33.material": {"materialRef": "770efcf2e3ad4e5493ec103921c21a33.material", "sortValue": 0}}, "reflectable": true, "cullMode": "Dynamic", "castShadows": true}, "script": {"scripts": {"5a517d930220410392b4583e88f840c2.scriptinstance": {"id": "5a517d930220410392b4583e88f840c2.scriptinstance", "name": "Instance of Text texture", "scriptRef": "72b440a4a1fd4493ba4f8d77b1399e4d.script", "sortValue": 0, "options": {"verticalAlign": "middle", "text": "LOADING TRACK", "enabled": true, "textAlign": "center", "wordWrap": true, "backgroundColor": [0, 0, 0], "lineHeight": 1.3, "font": "Helvetica", "margin": 20, "transparent": true, "texSize": 512}}}}}, "hidden": false, "id": "ae6a528167ca4709b0954b9ace7bcac8.entity"}, "107c4dcd5e1c48e1989dd9086aafed2a.script": {"body": "'use strict';\n\n/* global goo */\n\nvar clamp = function(number, min, max) {\n  return Math.max(min, Math.min(number, max));\n};\n\nvar mouseMove = function(ctx, x, y) {\n\tctx.relative[0] = (x - ctx.rect.width/2.0);\n\tctx.relative[1] = (y - ctx.rect.height/2.0);\n\t// ctx.worldData.relative = ctx.relative;\n};\n\nvar setup = function (args, ctx) {\n\t\n\tctx.rect = ctx.domElement.getBoundingClientRect();\n\tgoo.SystemBus.addListener('goo.viewportResize', function() {\n\t\tctx.rect = ctx.domElement.getBoundingClientRect();\n\t});\n\tctx.relative = [0, 0];\n\tctx.relativeSmooth = [0, 0];\n\tctx.windowListeners = {\n\t\tmousemove: function(evt) {\n\t\tmouseMove(ctx, evt.clientX, evt.clientY);\n\t\t}\n\t};\n\tObject.keys(ctx.windowListeners).forEach(function(v) {\n\twindow.addEventListener(v, ctx.windowListeners[v]);\n\t});\n\t\n\t\n    goo.Ajax.crossOrigin = true;\n    \n    function createSkySphere(ctx, material) {\n        material.cullState.cullFace = 'Front'; // cull the outside, keep the inside\n        material.depthState.enabled = false; // don't change the z-buffer\n        material.renderQueue = -1000; // draw this first\n        var skysphere = ctx.world.createEntity(new goo.Sphere(32, 32, 20, goo.Sphere.TextureModes.Linear), material);\n        skysphere.isSkybox = true; // activate special handling in renderer and for shadows\n        return skysphere;\n    }\n    \n        ctx.material = new goo.Material(goo.ShaderLib.textured);\n        ctx.material.setTexture('DIFFUSE_MAP', args.texture1);\n        ctx.skySphere = createSkySphere(ctx, ctx.material);\n        ctx.skySphere.addToWorld();\n        ctx.skySphere.setRotation(-Math.PI*0.5, 0, 0);\n\t\tctx.video = ctx.material.getTexture('DIFFUSE_MAP').image;\n};\n\nvar cleanup = function (args, ctx) {\n    if(ctx.skySphere !== undefined){\n        ctx.skySphere.removeFromWorld();\n    }\n\tObject.keys(ctx.windowListeners).forEach(function(v) {\n\twindow.removeEventListener(v, ctx.windowListeners[v]);\n\t});\n\t\n};\n\nvar update = function (args, ctx) {\n\tctx.skySphere.setTranslation(0,Math.sin(goo.World.time*10),0);\n\tif(ctx.relative[1]!==0) {\n\t\tctx.video.playbackRate = clamp(Math.abs(Math.floor(ctx.relative[1]/10)/10),0,2);\n\t  }\n\t\tconsole.log(ctx.video.playbackRate);\n\n};\n\nvar parameters = [\n        {key:'listenToStart', name: 'listenToVideo1', type: 'string', default: 'start'},\n        {key:'listenToStop', name: 'listenToVideo2', type: 'string', default: 'stop'},\n        {key:'texture1', type:'texture', default:null},\n        {key:'texture2', type:'texture', default:null},\n    ];", "name": "video_loader", "license": "CC0", "created": "2016-02-22T12:41:57.196Z", "deleted": false, "dataModelVersion": 2, "modified": "2016-02-22T12:41:57.196Z", "id": "107c4dcd5e1c48e1989dd9086aafed2a.script"}, "49f8edb7fcc0471e964c33ad54196e20.scene": {"canvas": {"resolution": {"width": 1920, "height": 1080}, "mode": "Stretch"}, "initialCameraRef": "64f47c2064f746999a6db20581dbfb40.entity", "description": "VR running with 360 video", "license": "PRIVATE", "created": "2016-02-26T15:47:10.165690+00:00", "deleted": false, "id": "49f8edb7fcc0471e964c33ad54196e20.scene", "thumbnailRef": "9ce7d991e20821433d551c35728fae33d1eebc13.png", "environmentRef": "cb3463698ada4635aaf75f1001f6233a.environment", "dataModelVersion": 2, "originalAsset": {"version": "e39b6ff680c4402a9949b27c96f1729a", "id": "ac9f46781def41a38e654aa43175edba"}, "modified": "2016-03-11T22:13:09.844316+00:00", "entities": {"4d2303a5ad484fea930530132d84ff03.entity": {"entityRef": "4d2303a5ad484fea930530132d84ff03.entity", "sortValue": 7}, "64f47c2064f746999a6db20581dbfb40.entity": {"entityRef": "64f47c2064f746999a6db20581dbfb40.entity", "sortValue": 4}, "ebc5ac6898234f0d8eb1e629b2a7d6c4.entity": {"entityRef": "ebc5ac6898234f0d8eb1e629b2a7d6c4.entity", "sortValue": 0}, "647ce9e6c5a74e879740fbd519c2be00.entity": {"entityRef": "647ce9e6c5a74e879740fbd519c2be00.entity", "sortValue": 6}, "5de059f428574f899590bffcf9725071.entity": {"entityRef": "5de059f428574f899590bffcf9725071.entity", "sortValue": 1}, "814eb3d13be3459fba60f42e75bac6e7.entity": {"entityRef": "814eb3d13be3459fba60f42e75bac6e7.entity", "sortValue": 8}, "ae6a528167ca4709b0954b9ace7bcac8.entity": {"entityRef": "ae6a528167ca4709b0954b9ace7bcac8.entity", "sortValue": 9}, "1357bc80a1434a92bd41040591f474f2.entity": {"entityRef": "1357bc80a1434a92bd41040591f474f2.entity", "sortValue": 3}}, "posteffectsRef": "28de9dae45fa4a43afd7989f5cae6098.posteffects", "published": "2016-03-11T22:13:08.292062+00:00", "packs": {"438f67eaff1f4e8b91f97c3d3eeaf431.pack": {"packRef": "438f67eaff1f4e8b91f97c3d3eeaf431.pack", "sortValue": 0}, "12c02855070841e592dec1864cc355f3.pack": {"packRef": "12c02855070841e592dec1864cc355f3.pack", "sortValue": 5}, "56ac7215e0f64edba617e5b0c095b796.pack": {"packRef": "56ac7215e0f64edba617e5b0c095b796.pack", "sortValue": 3}, "7cc0eb88b0de4331b605d6677bde8ea9.pack": {"packRef": "7cc0eb88b0de4331b605d6677bde8ea9.pack", "sortValue": 4}, "2739083de95c4dc5addb4e43fc558dd0.pack": {"packRef": "2739083de95c4dc5addb4e43fc558dd0.pack", "sortValue": 1}, "de72882b03ef4e89baab5c3c853e228c.pack": {"packRef": "de72882b03ef4e89baab5c3c853e228c.pack", "sortValue": 7}, "15fc0617a6d543eba6f64e65779707c1.pack": {"packRef": "15fc0617a6d543eba6f64e65779707c1.pack", "sortValue": 8}}, "defaultPackRef": "438f67eaff1f4e8b91f97c3d3eeaf431.pack", "publishedUrl": "https://c1.goote.ch/49f8edb7fcc0471e964c33ad54196e20.scene", "name": "VRun"}, "c74e3e7e0a354362bb528f8a38d3dbff.entity": {"name": "Directional 1", "license": "CC0", "tags": {}, "deleted": false, "created": "2015-07-27T15:45:29.198Z", "dataModelVersion": 2, "modified": "2015-07-27T15:45:29.198Z", "static": false, "components": {"light": {"direction": [0, 0, 0], "shadowCaster": false, "color": [1, 1, 1, 1], "intensity": 0.4, "range": 60, "specularIntensity": 1, "penumbra": 5, "angle": 30, "type": "DirectionalLight", "shadowSettings": {"fov": 55, "darkness": 1, "far": 60, "near": 1, "resolution": [256, 256], "shadowType": "Basic", "size": 100}}, "transform": {"rotation": [-31, 129, 0], "scale": [1, 1, 1], "translation": [15, 11.6, -12.2]}}, "hidden": false, "id": "c74e3e7e0a354362bb528f8a38d3dbff.entity"}, "b88ee439142b4ba5b918fdc3fd3cc83d.script": {"body": "\nvar setup = function(args, ctx, goo) {\n\tctx.pass = new RiftRenderPass(args, ctx, goo);\n\tctx.enabled = false;\n\t\n\tvar fov = ctx.entity.cameraComponent ? ctx.entity.cameraComponent.camera.fov : 80;\n\t\n\tctx.pass.updateConfig({\n\t\tdistortionK: [1.0, 0.0,0.0,0],\n\t\tchromAbParameter: [1,0,1,0],\n\t\tlensSeparationDistance: 0.096,\n\t\thResolution: ctx.viewportWidth,\n\t\tvResolution: ctx.viewportHeight,\n\t\thScreenSize: 0.128,\n\t\tvScreenSize: 0.192,\n\t\tinterpupillaryDistance: 0.096,\n\t\tFOV: fov\n\t});\n};\n\nvar cleanup = function(args, ctx, goo) {\n\tif (ctx.enabled) {\n\t\tPassSwitcher.switchBack(ctx, goo);\n\t}\n};\n\nvar update = function (args, ctx, goo) {\n\tif (ctx.activeCameraEntity === ctx.entity && !ctx.enabled) {\n\t\tPassSwitcher.switchPass(ctx.pass, ctx, goo);\n\t\tctx.enabled = true;\n\t} else if (ctx.activeCameraEntity !== ctx.entity && ctx.enabled) {\n\t\tPassSwitcher.switchBack(ctx, goo);\n\t\tctx.enabled = false;\n\t}\n}\n\nvar parameters = [{\n\tkey: 'boost3D',\n\tname: 'Boost 3D Effect',\n\ttype: 'float',\n\tcontrol: 'slider',\n\t'default': 1,\n\tmin: 1,\n\tmax: 20\n}];\n\n'use strict';\n(function() {\n\tfunction RiftRenderPass(args, ctx, goo) {\n\t\tthis.goo = goo;\n\t\tthis.ctx = ctx;\n\t\t\n\t\tthis.camera = new goo.Camera();\n\t\tthis.fullscreenCamera = goo.FullscreenUtil.camera;\n\t\tthis.renderToScreen = false;\n\t\tthis.clear = true;\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = true;\n\t\tthis.eyeOffset = 0.4;\n\t\tthis.fov = 100;\n\t\tthis.width = null;\n\t\tthis.height = null;\n\t\tthis._dc = 1.8; // Distortion compensation scale\n\n\t\t\n\t\t// Create composit\n\t\tthis.material = new goo.Material('Composit material', riftShader);\n\t\t\n\t\t// Create eye targets\n\t\tthis.updateSize({ width: ctx.viewportWidth, height: ctx.viewportHeight});\n\t\tthis.offsetVector = new goo.Vector3();\n\n\t\t\n\t\tthis.renderable = {\n\t\t\tmeshData: goo.FullscreenUtil.quad,\n\t\t\tmaterials: [this.material]\n\t\t};\n\n\t\t// get the renderlist\n\t\tthis.renderList = ctx.world.getSystem('RenderSystem').renderList;\n\t\tthis.setup(args, ctx, goo);\n\t}\n\t\n\tRiftRenderPass.prototype.setup = function(args) {\n\t\tthis.boost = args.boost3D || 1;\n\t};\n\tRiftRenderPass.prototype.destroy = function (renderer) {\n\t\tthis.leftTarget.destroy(renderer.context);\n\t\tthis.rightTarget.destroy(renderer.context);\n\t\tthis.leftTarget = null;\n\t\tthis.rightTarget = null;\n\t}\n\n\tRiftRenderPass.prototype.updateConfig = function (config) {\n\t\tvar uniforms = this.material.uniforms;\n\t\tuniforms.distortion = config.distortionK;\n\t\tuniforms.aberration = config.chromAbParameter;\n\t\tuniforms.lensCenterOffset = [\n\t\t\tconfig.lensSeparationDistance / config.hScreenSize - 0.5,\n\t\t\t0\n\t\t];\n\t\tthis.fov = config.FOV;\n\t\tthis.eyeOffset = config.interpupillaryDistance * this.boost;\n\n\n\t\tvar r = -1.0 - (4 * (config.hScreenSize/4 - config.lensSeparationDistance/2) / config.hScreenSize);\n\t\tvar distScale = (config.distortionK[0] +\n\t\t\tconfig.distortionK[1] * Math.pow(r,2) +\n\t\t\tconfig.distortionK[2] * Math.pow(r,4) +\n\t\t\tconfig.distortionK[3] * Math.pow(r,6));\n\t\tuniforms.scale = [\n\t\t\t1 / distScale,\n\t\t\t1 / distScale\n\t\t];\n\t\tthis.updateSize({ width: config.hResolution, height: config.vResolution })\n\t}\n\t\n\n\n\tRiftRenderPass.prototype.updateSize = function(size, renderer) {\n\t\tthis.material.uniforms.scaleIn = [\n\t\t\tsize.width * 0.5 / size.height,\n\t\t\t1\n\t\t];\n\t\tif (this.width === size.width && this.height === size.height) { return; }\n\t\tthis.width = size.width;\n\t\tthis.height = size.height;\n\t\tif (this.leftTarget) {\n\t\t\tthis.leftTarget.destroy(renderer.context)\n\t\t\tthis.rightTarget.destroy(renderer.context)\n\t\t}\n\t\t// size = { width: 2048, height: 2048 };\n\t\tthis.leftTarget = new this.goo.RenderTarget(size.width * 0.5 * this._dc, size.height * this._dc);\n\t\tthis.rightTarget = new this.goo.RenderTarget(size.width * 0.5 * this._dc, size.height * this._dc);\n\t};\n\n\tRiftRenderPass.prototype.render = function (\n\t\trenderer,\n\t\twriteBuffer,\n\t\treadBuffer,\n\t\tdelta,\n\t\tmaskActive,\n\t\tcamera,\n\t\tlights,\n\t\tclearColor\n\t) {\n\t\tcamera = camera || this.goo.Renderer.mainCamera;\n\t\tif (!camera) { return; }\n\t\tthis.camera.copy(camera);\n\t\tthis.camera.setFrustumPerspective(this.fov, 1);\n\t\tlights = lights || [];\n\t\tvar renderList = this.renderList;\n\t\t\n\t\t// Left eye\n\t\tthis.offsetVector.setVector(this.camera._left).scale(this.eyeOffset);\n\t\tthis.camera.translation.addVector(this.offsetVector);\n\t\tthis.camera.update();\n\t\trenderer.render(renderList, this.camera, lights, this.leftTarget, this.clear);\n\t\t\n\t\t// Right eye\n\t\tthis.offsetVector.scale(2);\n\t\tthis.camera.translation.subVector(this.offsetVector);\n\t\tthis.camera.update();\n\t\trenderer.render(renderList, this.camera, lights, this.rightTarget, this.clear);\n\t\t\n\t\t// Composit\n\t\tthis.material.setTexture('LEFT_TEX', this.leftTarget);\n\t\tthis.material.setTexture('RIGHT_TEX', this.rightTarget);\n\t\tif (this.renderToScreen) {\n\t\t\trenderer.render(this.renderable, this.fullscreenCamera, [], null, this.clear);\n\t\t} else {\n\t\t\trenderer.render(this.renderable, this.fullscreenCamera, [], writeBuffer, this.clear);\n\t\t}\n\t};\n\t\n\tRiftRenderPass.parameters = [{\n\t\tkey: 'eyeDistance',\n\t\ttype: 'float',\n\t\tmin: 0.0,\n\t\tmax: 0.4,\n\t\t'default': 0.1,\n\t\tcontrol: 'slider'\n\t}]\t\n\tvar riftShader = {\n\t\tattributes : {\n\t\t\tvertexPosition : 'POSITION',\n\t\t\tvertexUV0 : 'TEXCOORD0'\n\t\t},\n\t\tuniforms : {\n\t\t\tviewMatrix: 'VIEW_MATRIX',\n\t\t\tprojectionMatrix: 'PROJECTION_MATRIX',\n\t\t\tworldMatrix: 'WORLD_MATRIX',\n\t\t\tleftTex: 'LEFT_TEX',\n\t\t\trightTex: 'RIGHT_TEX',\n\t\t\tlensCenterOffset: [0, 0],\n\t\t\tdistortion: [1, 0.22, 0.24, 0],\n\t\t\taberration: [0.996, -0.004, 1.014, 0],\n\t\t\tscaleIn: [1,1],\n\t\t\tscale: [0.8,0.8]\n\t\t},\n\t\tvshader: [\n\t\t\t'attribute vec3 vertexPosition;',\n\t\t\t'attribute vec2 vertexUV0;',\n\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform mat4 worldMatrix;',\n\n\t\t\t'varying vec2 vUv;',\n\t\t\t'void main() {',\n\t\t\t\t'vUv = vertexUV0;',\n\t\t\t\t'gl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4( vertexPosition, 1.0 );',\n\t\t\t'}'\n\t\t].join('\\n'),\n\t\tfshader: [\n\t\t\t'uniform sampler2D leftTex;',\n\t\t\t'uniform sampler2D rightTex;',\n\n\t\t\t'uniform vec2 scaleIn;',\n\t\t\t'uniform vec2 scale;',\n\t\t\t'uniform vec2 lensCenterOffset;',\n\t\t\t'uniform vec4 distortion;',\n\t\t\t'uniform vec4 aberration;',\n\t\t\t\n\t\t\t'varying vec2 vUv;',\n\n\t\t\t'vec2 distort(vec2 texCoords, vec2 ab) {',\n\t\t\t\t// 'vec2 lensOffset = vUv.x > 0.5 ? lensCenterOffset: -lensCenterOffset;',\n\t\t\t\t'vec2 lensCoords = ((texCoords * 2.0 - 1.0) - lensCenterOffset) * scaleIn;',\n\n\t\t\t\t'float rSq = dot(lensCoords, lensCoords);',\n\t\t\t\t'vec4 r = vec4(1.0, rSq, rSq*rSq, rSq*rSq*rSq);',\n\n\t\t\t\t'vec2 newCoords = lensCoords * dot(ab, r.xy) * dot(distortion, r);',\n\t\t\t\t'return ((newCoords * scale + lensCenterOffset) + 1.0) / 2.0;',\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\t\t\t\t'vec2 coord = vUv;',\n\t\t\t\t'if (vUv.x > 0.5) {', // Right eye\n\t\t\t\t\t'coord.x = 1.0 - coord.x;',\n\t\t\t\t'}',\n\t\t\t\t'coord.x *= 2.0;',\n\n\t\t\t\t'vec2 blue = distort(coord, aberration.zw);',\n\t\t\t\t'if (!all(equal(clamp(blue, vec2(0.0), vec2(1.0)), blue))) {',\n\t\t\t\t\t'discard;',\n\t\t\t\t'}',\n\n\t\t\t\t'vec2 red = distort(coord, aberration.xy);',\n\t\t\t\t'vec2 green = distort(coord, vec2(1.0, 0.0));',\n\t\t\t\t'gl_FragColor.a = 1.0;',\n\t\t\t\t'if (vUv.x > 0.5) {',\n\t\t\t\t\t'red.x = 1.0 - red.x;',\n\t\t\t\t\t'green.x = 1.0 - green.x;',\n\t\t\t\t\t'blue.x = 1.0 - blue.x;',\n\n\t\t\t\t\t'gl_FragColor.r = texture2D(rightTex, red).r;',\n\t\t\t\t\t'gl_FragColor.g = texture2D(rightTex, green).g;',\n\t\t\t\t\t'gl_FragColor.b = texture2D(rightTex, blue).b;',\n\t\t\t\t'} else {',\n\t\t\t\t\t'gl_FragColor.r = texture2D(leftTex, red).r;',\n\t\t\t\t\t'gl_FragColor.g = texture2D(leftTex, green).g;',\n\t\t\t\t\t'gl_FragColor.b = texture2D(leftTex, blue).b;',\n\t\t\t\t'}',\n\t\t\t'}'\n\t\t].join('\\n')\n\t};\n\n\twindow.RiftRenderPass = RiftRenderPass;\n}());\n\n'use strict';\n(function(global) {\n\tvar originalPass = null;\n\tvar originalComposer = null;\n\tvar addedPass = null;\n\t\n\tvar PassSwitcher = {\n\t\tswitchPass: function(pass, ctx, goo) {\n\t\t\taddedPass = pass;\n\t\t\tvar renderSystem = ctx.world.getSystem('RenderSystem');\n\t\t\t// Get or create composer\n\t\t\tvar composer\n\t\t\tif (renderSystem.composers.length) {\n\t\t\t\tcomposer = renderSystem.composers[0];\n\t\t\t\toriginalPass = composer.passes.shift();\n\t\t\t\tpass.renderToScreen = false;\n\t\t\t} else {\n\t\t\t\toriginalComposer = composer = new goo.Composer();\n\t\t\t\trenderSystem.composers.push(composer);\n\t\t\t\tpass.renderToScreen = true;\n\t\t\t}\n\t\t\t// Add the post effect\n\t\t\tcomposer.passes.unshift(pass);\n\t\t\tif (composer.size) {\n\t\t\t\tif (pass.updateSize instanceof Function) {\n\t\t\t\t\tpass.updateSize(composer.size, ctx.world.gooRunner.renderer);\n\t\t\t\t}\n\t\t\t\tpass.viewportSize = composer.size;\n\t\t\t}\n\t\t},\n\t\tswitchBack: function(ctx, goo) {\n\t\t\tvar renderSystem = ctx.world.getSystem('RenderSystem');\n\t\t\tif (originalComposer) {\n\t\t\t\toriginalComposer.destroy(ctx.world.gooRunner.renderer)\n\t\t\t\t// If we created a post effect chain, remove it\n\t\t\t\tgoo.ArrayUtil.remove(renderSystem.composers, originalComposer);\n\t\t\t} else {\n\t\t\t\t// Otherwise, remove the post effect and put back the outpass\n\t\t\t\tvar composer = renderSystem.composers[0];\n\t\t\t\tgoo.ArrayUtil.remove(composer.passes, addedPass);\n\t\t\t\tcomposer.passes.unshift(originalPass);\n\t\t\t}\n\t\t}\n\t};\n\tglobal.PassSwitcher = PassSwitcher;\n}(window));", "name": "VR Render Script", "license": "CC0", "created": "2015-06-25T11:28:03.992781+00:00", "deleted": false, "dataModelVersion": 2, "modified": "2015-06-25T11:28:05.534532+00:00", "dependencies": {}, "id": "b88ee439142b4ba5b918fdc3fd3cc83d.script"}, "e46c79eb1221479fa6ea670616a3012a.script": {"body": "var addBarycentric = function (entity) {\n\tentity.meshDataComponent.meshData = entity.meshDataComponent.meshData.buildFlatMeshData();\n\tvar meshData = entity.meshDataComponent.meshData;\n\n\tmeshData.attributeMap.BARYCENTRIC = goo.MeshData.createAttribute(3, 'Float');\n\tmeshData.rebuildData(meshData.vertexCount, 0, true);\n\n\tvar barycentricBuffer = meshData.getAttributeBuffer('BARYCENTRIC');\n\tvar vertexCount = meshData.vertexCount;\n\tfor (var a = 0; a < vertexCount; a += 3) {\n\t\tbarycentricBuffer[a * 3 + 0] = 1;\n\t\tbarycentricBuffer[a * 3 + 1] = 0;\n\t\tbarycentricBuffer[a * 3 + 2] = 0;\n\t\tbarycentricBuffer[a * 3 + 3] = 0;\n\t\tbarycentricBuffer[a * 3 + 4] = 1;\n\t\tbarycentricBuffer[a * 3 + 5] = 0;\n\t\tbarycentricBuffer[a * 3 + 6] = 0;\n\t\tbarycentricBuffer[a * 3 + 7] = 0;\n\t\tbarycentricBuffer[a * 3 + 8] = 1;\n\t}\n};\n\nvar parameters = [\n\t{key:'texture', type:'texture', default:null},\n \t{ key: 'lineWidth', type: 'float', default: 1 },\n    { key: 'baseColor', type: 'vec3', control: 'color', default: [0, 0, 0] },\n    { key: 'lineColor', type: 'vec3', control: 'color', default: [1, 1, 1] },\n    { key: 'transparency', type: 'boolean', default: false }\t\n];\n\t\nvar setup = function(args, ctx, goo){\n\t\n\tvar material = new goo.Material('WireShader', wireShaderDef);\n\tmaterial.uniforms.lineWidth = args.lineWidth;\n\tmaterial.uniforms.baseColor = args.baseColor;\n\tmaterial.uniforms.lineColor = args.lineColor;\n\tmaterial.uniforms.transparency = args.transparency;\n//\tmaterial.blendState.blending = 'AdditiveBlending';\n\tif (args.transparency) {\n\t\tmaterial.blendState.blending = 'TransparencyBlending';\n\t\tmaterial.renderQueue = goo.RenderQueue.TRANSPARENT;\n\t}\n\n\t\tvar image = args.texture.image;\n\t\tvar imgCanvas = document.createElement('canvas');\n\t\timgCanvas.width = image.width;\n\t\timgCanvas.height = image.height;\n\t\timgCanvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);\n\t\t\n\t\tfunction getHeightMap(canvas, scale) {\n\t\t\tvar matrix = [];\n\t\t\tfor (var y = 0, ylen = canvas.height; y < ylen; y++) {\n\t\t\t\tmatrix.push([]);\n\t\t\t\tfor (var x = 0, xlen = canvas.width; x < xlen; x++) {\n\t\t\t\t\tvar rgb = canvas.getContext('2d').getImageData(x, y, 1, 1).data;\n\t\t\t\t\tvar value = rgb[0]+rgb[1]+rgb[2] / 3;\n\t\t\t\t\tmatrix[y].push(value * scale);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matrix;\n\t\t}\n\t\t\n\t\n\t\t\n\t\tvar heightMap = getHeightMap(imgCanvas, 0.06);\n\t\tvar meshData = goo.Surface.createFromHeightMap(heightMap, 5, 5, 5);\n// \t\tvar material = new goo.Material(goo.ShaderLib.simpleLit);\n\t\n\t\tmaterial.cullState.enabled = false;\n\t\t\n\t\tctx.worldData.heightMap = ctx.world.createEntity(meshData, material).addToWorld();\n\t\tctx.worldData.heightMap.transformComponent.setTranslation(-750,-20,-730);\n\t\tctx.worldData.heightMap.transformComponent.setUpdated();\n\t\taddBarycentric(ctx.worldData.heightMap);\n// \t\tconsole.log(ctx.heightMap);\n\n};\n\nvar cleanup = function(args, ctx, goo){\n\tif(ctx.worldData.heightMap !== undefined){\n\t\tctx.worldData.heightMap.removeFromWorld();\n\t}\n};\n\n\nvar wireShaderDef = {\n\tprocessors: [\n\t\tgoo.ShaderBuilder.animation.processor\n\t],\n\tdefines: {\n\t\tSHADOW_TYPE: 0,\n\t\tFOG:true,\n\t\tWEIGHTS: true,\n\t\tJOINTIDS: true\n\t},\n\tattributes: {\n\t\tvertexPosition: goo.MeshData.POSITION,\n\t\tvertexNormal: goo.MeshData.NORMAL,\n\t\tvertexUV0: goo.MeshData.TEXCOORD0,\n\t\tvertexColors: goo.MeshData.COLOR,\n\t\tvertexJointIDs: goo.MeshData.JOINTIDS,\n\t\tvertexWeights: goo.MeshData.WEIGHTS,\n\t\tbarycentric: 'BARYCENTRIC'\n\t},\n\tuniforms: {\n\t\tviewProjectionMatrix: goo.Shader.VIEW_PROJECTION_MATRIX,\n\t\tworldMatrix: goo.Shader.WORLD_MATRIX,\n\t\tdiffuseMap: goo.Shader.DIFFUSE_MAP,\n\t\tcameraPosition: goo.Shader.CAMERA,\n\t\tnormalMatrix: goo.Shader.NORMAL_MATRIX,\n\t\tlineWidth: 1,\n\t\tbaseColor: [0.0, 0.0, 0.0],\n\t\tlineColor: [1.0, 1.0, 1.0],\n\t\ttransparency: false,\n\t\tfogSettings: function() {return goo.ShaderBuilder.FOG_SETTINGS;},\n\t\tfogColor: goo.ShaderBuilder.FOG_COLOR,\n\t\tu_time : function() {return goo.World.time;}\n\t},\n\tvshader: [\n\t\t'attribute vec3 vertexPosition;',\n\t\t'attribute vec3 vertexColors;',\n\t\t'attribute vec2 vertexUV0;',\n\t\t\"attribute vec3 vertexNormal;\",\n\t\t'attribute vec3 barycentric;',\n\n\t\t'uniform mat4 viewProjectionMatrix;',\n\t\t'uniform mat4 worldMatrix;',\n\t\t'uniform mat3 normalMatrix;',\n\t\t\"uniform vec3 cameraPosition;\",\n\t\t\"uniform float u_time;\",\n\t\t\t\t\n\t\t\"varying vec3 viewPosition;\",\n\t\t'varying vec2 texCoord0;',\n\t\t'varying vec3 color;',\n\t\t'varying vec3 vBC;',\n\t\t\"varying vec3 normal;\",\n\t\t\"varying vec4 worldPos;\",\n\t\t\n\t\t'#ifdef FOG',\n\t\t\t'uniform vec2 fogSettings;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t'#endif',\n\n\t\tgoo.ShaderBuilder.animation.prevertex,\n\n\t\t'void main(void) {',\n\t\t\t'color = vertexColors;',\n\t\t\t'mat4 wMatrix = worldMatrix;',\n\t\t\tgoo.ShaderBuilder.animation.vertex,\n\t\t\t'texCoord0 = vertexUV0;',\n\t\t\t'vBC = barycentric;',\n\t\t\t\"worldPos = worldMatrix * vec4(vertexPosition, 1.0);\",\n\t\t\t'gl_Position = viewProjectionMatrix * worldPos;',\n\t\t\t\"viewPosition = cameraPosition - worldPos.xyz;\",\n\t\t\t\"normal = (worldMatrix * vec4(vertexNormal, 0.0)).xyz;\",\n\t\t'}'\n\t].join('\\n'),\n\tfshader: [\n\t\t'uniform sampler2D diffuseMap;',\n\t\t'uniform float lineWidth;',\n\t\t'uniform vec3 baseColor;',\n\t\t'uniform vec3 lineColor;',\n\t\t'uniform bool transparency;',\n\t\t'uniform mat3 normalMatrix;',\n\t\t\"uniform float u_time;\",\n\n\t\t'varying vec2 texCoord0;',\n\t\t'varying vec3 vBC;',\n\t\t'varying vec3 color;',\n\t\t\"varying vec3 viewPosition;\",\n\t\t\"varying vec3 normal;\",\n\t\t\"varying vec4 worldPos;\",\n\t\t\n\t\t'#ifdef FOG',\n\t\t\t'uniform vec2 fogSettings;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t '#endif',\n\n\t\t'#extension GL_OES_standard_derivatives : enable',\n\n\t\t'float edgeFactor() {',\n\t\t\t'vec3 d = fwidth(vBC);',\n\t\t\t'vec3 a3 = smoothstep(vec3(0.0), d * lineWidth, vBC);',\n\t\t\t'return 1.0 - min(min(a3.x, a3.y), a3.z);',\n\t\t'}',\n\n\t\t'void main(void) {',\n\t\t\t'float edge = edgeFactor();',\n// \t\t\t'vec3 lines = lineColor*color;',\n// \t\t\t'vec3 fill = baseColor*color;',\n\t\t\t'vec3 dark = vec3(0.0,0.0,0.0);',\n\t/*\t\t\n\t\t\t'float bValue = 0.0;',\n\t\t\t'float Radius = 10.0;',\n\n\t\t\t'float distanceCalculation = distance(viewPosition*(0.0-(Radius/10000.0)), worldPos.xyz*(0.0-(Radius/10000.0)));',\n\t\t\t'vec3 eyeNormal = (normalMatrix*normal)* 0.5 + 0.5;',\n\t\t\t'float cFresnel = clamp(dot(viewPosition, eyeNormal),0.0,1.0);',\n\t\t\t'vec3 invertFresnel = vec3(1, 1, 1) - vec3(cFresnel, cFresnel, cFresnel);',\n\t\t\t'float scanSync = clamp((mix(cFresnel, bValue, distanceCalculation)),0.0,1.0);',\n\t\t\t'float manualScan = clamp((((distance(viewPosition, worldPos.xyz))-100000.0)/10000.0),0.0,1.0);',\n\t\t\n\t*/\t\n\t\t/*\n\t\t\t'if (transparency) {',\n\t\t\t\t'gl_FragColor = vec4(lines, edge);',\n\t\t\t'} else {',\n\t\t\t\t'gl_FragColor.rgb = mix(fill, lines, edge);',\n\t\t\t\t'gl_FragColor.a = 1.0;',\n\t\t\t'}',\n\t\t*/\n\t\t'vec3 mainColor = mix(baseColor, lineColor*1.5, edge);',\n\t\t'vec3 linesOnly = mix(dark, lineColor*1.5, edge);',\n\t\t\n//    \t\t'float dist1 = pow(smoothstep(fogSettings.x, fogSettings.y, tan(length(viewPosition))), 1.0);',\n//\t\t\t'float dist2 = pow(smoothstep(fogSettings.x, fogSettings.y, tan(length(viewPosition))), 0.2);',\n//\t\t\t'float dist3 = pow(smoothstep(0.0, 100.0, tan(length(viewPosition*clamp(cos(u_time*0.1)*0.2, 0.0,1.0)))*0.7), 0.2);',\n\t\t\t'float dist3 = pow(smoothstep(0.0, 50.0, tan(length(viewPosition)*0.004-fract(u_time*0.01)*100.0)), 0.6);',\n\t\t\t'vec3 fog1 = mix(dark, mainColor, dist3);',\n\t\t\t'vec3 fog2 = mix(dark, fogColor,  dist3);',\n      \t\t'gl_FragColor.rgb = fog1+fog2/3.0;',\n// \t\t\t'gl_FragColor.rgb = mainColor;',\n\t\t\t\n// \t\t\t'if (transparency) {',\n//                 'gl_FragColor = vec4(lineColor, edge);',\n//             '} else {',\n// // \t\t\t\t'vec3 line = mix(lineColor, fogColor, worldPos.y);',\n//                 'gl_FragColor.rgb = mix(baseColor, lineColor, edge);',\n// \t\t\t'}',\n\t\t\t'gl_FragColor.a = 1.0;',\n//\t\t\t'gl_FragColor.rgb = fog1;',\n\n\t\t'}'\n\t].join('\\n')\n};\n", "name": "height_map", "license": "CC0", "created": "2015-02-03T14:17:11.627030+00:00", "deleted": false, "dataModelVersion": 2, "modified": "2015-02-03T14:17:11.627030+00:00", "dependencies": {"https://code.gooengine.com/latest/lib/geometrypack.js": {"url": "https://code.gooengine.com/latest/lib/geometrypack.js", "sortValue": 0}}, "id": "e46c79eb1221479fa6ea670616a3012a.script"}, "f262bb7418044b34ae6100230b7988c4.script": {"body": "/**\n * Stream video in Goo Create!\n * 1. Upload a video to Create by dropping the file into the asset bin.\n * 2. Put it in the videoTexture slot in this script.\n * 3. Publish.\n * 4. Copy the URL of the video in the published scene.\n * 5. Paste the URL in the videoUrl parameter input.\n * 6. Set the texture as lazy load.\n * 7. Done!\n */\n\n'use strict';\n\n/* global goo */\n\nvar clamp = function(number, min, max) {\n  return Math.max(min, Math.min(number, max));\n};\n\nvar mouseMove = function(ctx, x, y) {\n\tctx.relative[0] = (x - ctx.rect.width/2.0);\n\tctx.relative[1] = (y - ctx.rect.height/2.0);\n\t// ctx.worldData.relative = ctx.relative;\n};\n\nvar setup = function (args, ctx) {\n\tfunction createSkySphere(ctx, material) {\n        material.cullState.cullFace = 'Front'; // cull the outside, keep the inside\n        material.depthState.enabled = false; // don't change the z-buffer\n        material.renderQueue = -1000; // draw this first\n        var skysphere = ctx.world.createEntity(new goo.Sphere(32, 32, 20, goo.Sphere.TextureModes.Linear), material);\n        skysphere.isSkybox = true; // activate special handling in renderer and for shadows\n        return skysphere;\n    }\n\t\n\tvar video = document.createElement('video');\n\tvideo.src = args.videoUrl;\n\tvideo.oncanplay = function(){\n\t\tctx.canPlay = true;\n\t\tctx.video = video;\n\t};\n\t\n// \t\tctx.rect = ctx.domElement.getBoundingClientRect();\n// \tgoo.SystemBus.addListener('goo.viewportResize', function() {\n// \t\tctx.rect = ctx.domElement.getBoundingClientRect();\n// \t});\n// \tctx.relative = [0, 0];\n// \tctx.relativeSmooth = [0, 0];\n// \tctx.windowListeners = {\n// \t\tmousemove: function(evt) {\n// \t\tmouseMove(ctx, evt.clientX, evt.clientY);\n// \t\t}\n// \t};\n// \tObject.keys(ctx.windowListeners).forEach(function(v) {\n// \twindow.addEventListener(v, ctx.windowListeners[v]);\n// \t});\n\t\t\n\tctx.listeners = {\n\t\tmousedown: function(){\n\t\t\tif(ctx.canPlay && !ctx.started){\n\t\t\t\tctx.world.by.name('text').first().hide();\n\t\t\t\tctx.worldData.heightMap.hide();\n\t\t\t\tvideo.play();\n\t\t\t\tvideo.width = video.videoWidth;\n\t\t\t\tvideo.height = video.videoHeight;\n\t\t\t\tvideo.loop = true;\n\t\t\t\tvar texture = new goo.Texture();\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttexture.minFilter = 'BilinearNoMipMaps';\n\t\t\t\ttexture.setImage(video);\n\t\t\t\tctx.material = new goo.Material(goo.ShaderLib.textured);\tctx.material.uniforms.materialDiffuse = [1,1,0,1];\n\t\t\t\tctx.material.setTexture('DIFFUSE_MAP', texture);\n\t\t\t\tctx.skySphere = createSkySphere(ctx, ctx.material);\n\t\t\t\tctx.skySphere.addToWorld();\n\t\t\t\tctx.skySphere.setRotation(-Math.PI*0.5, Math.PI*1.0, 0);\n\t\t\t\ttexture.updateCallback = function () {\n\t\t\t\t\treturn !video.paused;\n\t\t\t\t};\n\t\t\t\tctx.texture = texture;\n\t\t\t\tctx.started = true;\n\t\t\t\tvideo.dataReady = true;\n\t\t\t}\n\t\t}\n\t};\n\tctx.listeners.touchend = ctx.listeners.mousedown;\n\tfor(var key in ctx.listeners){\n\t\tctx.domElement.addEventListener(key, ctx.listeners[key]);\n\t}\n    \n//         ctx.material = new goo.Material(goo.ShaderLib.textured);\n//         ctx.material.setTexture('DIFFUSE_MAP', args.texture1);\n//         ctx.skySphere = createSkySphere(ctx, ctx.material);\n//         ctx.skySphere.addToWorld();\n//         ctx.skySphere.setRotation(-Math.PI*0.5, 0, 0);\n// \t\tctx.video = ctx.material.getTexture('DIFFUSE_MAP').image;\n};\n\nvar cleanup = function (args, ctx) {\n\tif(ctx.skySphere !== undefined){\n        ctx.skySphere.removeFromWorld();\n    }\n\tfor(var key in ctx.listeners){\n\t\tctx.domElement.removeEventListener(key, ctx.listeners[key]);\n\t}\n};\n\nvar parameters = [{\n\tkey: 'videoUrl',\n\ttype: 'string',\n\t'default': ''\n},{\n\tkey: 'videoTexture',\n\ttype: 'texture'\n}];", "name": "Stream video script", "license": "CC0", "created": "2016-02-26T10:46:44.368Z", "deleted": false, "dataModelVersion": 2, "modified": "2016-02-26T10:46:44.368Z", "id": "f262bb7418044b34ae6100230b7988c4.script"}, "5de059f428574f899590bffcf9725071.entity": {"name": "Default Lights", "license": "CC0", "tags": {}, "deleted": false, "created": "2015-07-27T15:45:29.194Z", "dataModelVersion": 2, "modified": "2015-07-27T15:45:29.194Z", "static": false, "components": {"transform": {"rotation": [0, 0, 0], "scale": [1, 1, 1], "translation": [0, 0, 0], "children": {"c74e3e7e0a354362bb528f8a38d3dbff.entity": {"entityRef": "c74e3e7e0a354362bb528f8a38d3dbff.entity", "sortValue": 1}, "843d5c34d3e6452fa3b44517b4b1488e.entity": {"entityRef": "843d5c34d3e6452fa3b44517b4b1488e.entity", "sortValue": 0}}}}, "hidden": true, "id": "5de059f428574f899590bffcf9725071.entity"}, "f758d1b3cb4f4a43b36de389c39550d0.script": {"body": "var setup = function(args, ctx, goo) {\n\tctx.touch = function() {\n\t\tif (!document.fullscreenElement) {\n\t\t\tdocument.documentElement.requestFullScreen();\n\t\t}\n\t};\n\tctx.domElement.addEventListener('touchstart', ctx.touch);\n};\nvar cleanup = function(args, ctx, goo) {\n\tctx.domElement.removeEventListener('touchstart', ctx.touch);\n};\n\n", "name": "Full screen", "license": "CC0", "created": "2015-06-25T11:28:03.738412+00:00", "deleted": false, "dataModelVersion": 2, "modified": "2015-06-25T11:28:05.451665+00:00", "dependencies": {}, "id": "f758d1b3cb4f4a43b36de389c39550d0.script"}, "1357bc80a1434a92bd41040591f474f2.entity": {"name": "Box", "license": "CC0", "tags": {}, "deleted": false, "created": "2016-02-22T14:26:02.843Z", "dataModelVersion": 2, "modified": "2016-02-22T14:26:02.843Z", "static": false, "components": {"meshData": {"shape": "Box", "shapeOptions": {"textureMode": "Unfolded"}}, "transform": {"rotation": [0, 0, 0], "scale": [1, 1, 1], "translation": [0, 0, 0]}, "meshRenderer": {"receiveShadows": true, "materials": {"92aca09436674360863731d38f23827a.material": {"materialRef": "92aca09436674360863731d38f23827a.material", "sortValue": 0}}, "reflectable": true, "cullMode": "Dynamic", "castShadows": true}, "script": {"scripts": {"a64bbd1698ba4d06b7802fa26f9febca.scriptinstance": {"id": "a64bbd1698ba4d06b7802fa26f9febca.scriptinstance", "name": "Instance of video_loader", "scriptRef": "107c4dcd5e1c48e1989dd9086aafed2a.script", "sortValue": 0, "options": {"texture2": {"enabled": true}, "texture1": {"enabled": true}, "enabled": false, "listenToStop": "stop", "listenToStart": "start"}}}}}, "hidden": true, "id": "1357bc80a1434a92bd41040591f474f2.entity"}, "763dc89e7b4649bea068cff5bd7797e4.entity": {"name": "VRDescription", "license": "CC0", "tags": {}, "deleted": false, "created": "2016-02-24T09:01:44.626Z", "dataModelVersion": 2, "modified": "2016-02-24T09:01:44.626Z", "static": false, "components": {"html": {"imageRefs": {}, "useTransformComponent": true, "innerHtml": "<div style=\"width:200px;\">\n<p style=\"font-size:12px;padding:4px;margin:0;border-radius:3px; font-family:roboto, helvetica, sans-serif; color:white\">\n\t<b>VR CAMERA<hr style=\"margin-left:4px; width:180px\"></b><p style=\"font-size:12px;padding:4px;margin:0;border-radius:3px; font-family:roboto, helvetica, sans-serif; color:white\">\n\tThe VR Camera consists of three different scripts working together as one. Open up the Scripts tab to view the settings. <br><br>\n\tVR Render Script is the renderer, dividing the screen in two segments that are essential for a VR experience. The \"Boost 3D Effect\" slider decides the distance between the \"eyes\". In general, upping the number gives a more accentuated 3D experience.<br><br>The Device Orientation script controls the camera movement. It taps in on the gyroscope of your mobile. If you uncheck the Absolute checkbox, the camera position will adjust to your device's starting position. The Lerp controls how smoothly the camera will follow your gyro, with 1 being the camera following your movements very precise.<br><br>Full Screen gets rid of the browser interface, which could otherwise distract or in some cases destroy the VR experience.<br><br><b>Note:</b> don't forget to set the VR camera as the main camera, and have post effects on. To toggle the post effects on and off, click the wand icon above the Create viewport, or press 3 on your keyboard.<br><br>To hide this message, please expand the VR Camera entity in the hierarchy, and press the eye icon next to \"VRDescription\".\n\t\n\t\n</p>\n</div>"}, "transform": {"rotation": [0, 0, 0], "scale": [1, 1, 1], "translation": [-0.8148342370986938, 0.28002703189849854, 0]}}, "hidden": true, "id": "763dc89e7b4649bea068cff5bd7797e4.entity"}, "4cfc09f9b76a4f4cad4a6032cdf0744a.material": {"flat": true, "cullState": {"frontFace": "CCW", "enabled": true, "cullFace": "Back"}, "uniforms": {"opacity": {"enabled": false, "value": 1}, "refractivity": {"enabled": false, "value": 0}, "materialAmbient": {"enabled": true, "value": [0.3041666666666667, 1, 0.6981311274509803, 1]}, "materialSpecular": {"enabled": true, "value": [0.6, 0.6, 0.6, 1]}, "fresnel": {"enabled": true, "value": 0.5}, "reflectivity": {"enabled": true, "value": 0.6}, "materialSpecularPower": {"enabled": true, "value": 64}, "materialDiffuse": {"enabled": true, "value": [0.8, 0.8, 0.8, 1]}, "vertexColorAmount": {"enabled": true, "value": 1}, "materialEmissive": {"enabled": true, "value": [0, 0, 0, 1]}, "discardThreshold": {"enabled": true, "value": 0.1}, "normalMultiplier": {"enabled": true, "value": 1}, "etaRatio": {"enabled": true, "value": -0.5}, "reflectionType": 0, "wrapSettings": {"enabled": true, "value": [0, 0]}}, "name": "Default Material 3", "license": "CC0", "created": "2016-02-26T15:46:13.823Z", "deleted": false, "id": "4cfc09f9b76a4f4cad4a6032cdf0744a.material", "wireframe": false, "dataModelVersion": 2, "blendState": {"blendSrc": "SrcAlphaFactor", "blendDst": "OneMinusSrcAlphaFactor", "blendEquation": "AddEquation", "blending": "NoBlending"}, "modified": "2016-02-26T15:46:13.823Z", "dualTransparency": false, "depthState": {"write": true, "enabled": true}, "shaderRef": "GOO_ENGINE_SHADERS/uber", "texturesMapping": {}, "renderQueue": -1}}